scalar AWSTimestamp
scalar AWSDate
scalar AWSTime
scalar AWSDateTime
scalar AWSEmail
scalar AWSJSON
scalar AWSURL
scalar AWSPhone
scalar AWSIPAddress

type GameSession @model @auth(rules: [{allow: public}]) {
  id: ID!
  hostId: ID!
  guestId: ID
  adventureId: ID!
  currentQuestionIndex: Int!
  hostScore: Int!
  guestScore: Int!
  status: GameSessionStatus!
  questions: [Question]!
  questionScores: [QuestionScore]!
  lastUpdateTimestamp: AWSTimestamp!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type Question @model @auth(rules: [{allow: public}]) {
  id: ID!
  question: String!
  options: [String!]!
  correctAnswer: String!
}

type QuestionScore {
  questionIndex: Int!
  hostScore: Int!
  guestScore: Int!
}

type Subscription {
  onUpdateGameSession(id: ID!): GameSession
    @aws_subscribe(mutations: ["updateGameSession"])
}

enum GameSessionStatus {
  WAITING_FOR_PLAYER
  IN_PROGRESS
  COMPLETED
}

input CreateGameSessionInput {
  hostId: ID!
  adventureId: ID!
}

input JoinGameSessionInput {
  sessionId: ID!
  guestId: ID!
}

input AnswerQuestionInput {
  sessionId: ID!
  playerId: ID!
  answer: String!
  answerTime: AWSTimestamp!
}

type Mutation {
  createGameSession(input: CreateGameSessionInput!): GameSession
  joinGameSession(input: JoinGameSessionInput!): GameSession
  answerQuestion(input: AnswerQuestionInput!): GameSession
  startGameSession(sessionId: ID!): GameSession
}

type Query {
  getGameSession(id: ID!): GameSession
  listGameSessions: [GameSession]
}